(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["app-6f84c08c"],{"00e3":function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.shake256=e.shake128=e.keccak_512=e.keccak_384=e.keccak_256=e.keccak_224=e.sha3_512=e.sha3_384=e.sha3_256=e.sha3_224=e.Keccak=e.keccakP=void 0;const r=n("b40a"),o=n("5220"),s=n("531d"),[i,a,c]=[[],[],[]],f=BigInt(0),u=BigInt(1),d=BigInt(2),h=BigInt(7),l=BigInt(256),y=BigInt(113);for(let v=0,S=u,A=1,I=0;v<24;v++){[A,I]=[I,(2*A+3*I)%5],i.push(2*(5*I+A)),a.push((v+1)*(v+2)/2%64);let t=f;for(let e=0;e<7;e++)S=(S<<u^(S>>h)*y)%l,S&d&&(t^=u<<(u<<BigInt(e))-u);c.push(t)}const[p,b]=(0,o.split)(c,!0),w=(t,e,n)=>n>32?(0,o.rotlBH)(t,e,n):(0,o.rotlSH)(t,e,n),g=(t,e,n)=>n>32?(0,o.rotlBL)(t,e,n):(0,o.rotlSL)(t,e,n);function m(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let r=0;r<10;r++)n[r]=t[r]^t[r+10]^t[r+20]^t[r+30]^t[r+40];for(let r=0;r<10;r+=2){const e=(r+8)%10,o=(r+2)%10,s=n[o],i=n[o+1],a=w(s,i,1)^n[e],c=g(s,i,1)^n[e+1];for(let n=0;n<50;n+=10)t[r+n]^=a,t[r+n+1]^=c}let e=t[2],o=t[3];for(let n=0;n<24;n++){const r=a[n],s=w(e,o,r),c=g(e,o,r),f=i[n];e=t[f],o=t[f+1],t[f]=s,t[f+1]=c}for(let r=0;r<50;r+=10){for(let e=0;e<10;e++)n[e]=t[r+e];for(let e=0;e<10;e++)t[r+e]^=~n[(e+2)%10]&n[(e+4)%10]}t[0]^=p[r],t[1]^=b[r]}n.fill(0)}e.keccakP=m;class B extends s.Hash{constructor(t,e,n,o=!1,i=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=n,this.enableXOF=o,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,r.number)(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,s.u32)(this.state)}keccak(){m(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){(0,r.exists)(this);const{blockLen:e,state:n}=this;t=(0,s.toBytes)(t);const o=t.length;for(let r=0;r<o;){const s=Math.min(e-this.pos,o-r);for(let e=0;e<s;e++)n[this.pos++]^=t[r++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:r}=this;t[n]^=e,0!==(128&e)&&n===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){(0,r.exists)(this,!1),(0,r.bytes)(t),this.finish();const e=this.state,{blockLen:n}=this;for(let r=0,o=t.length;r<o;){this.posOut>=n&&this.keccak();const s=Math.min(n-this.posOut,o-r);t.set(e.subarray(this.posOut,this.posOut+s),r),this.posOut+=s,r+=s}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return(0,r.number)(t),this.xofInto(new Uint8Array(t))}digestInto(t){if((0,r.output)(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:r,rounds:o,enableXOF:s}=this;return t||(t=new B(e,n,r,s,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=n,t.outputLen=r,t.enableXOF=s,t.destroyed=this.destroyed,t}}e.Keccak=B;const E=(t,e,n)=>(0,s.wrapConstructor)(()=>new B(e,t,n));e.sha3_224=E(6,144,28),e.sha3_256=E(6,136,32),e.sha3_384=E(6,104,48),e.sha3_512=E(6,72,64),e.keccak_224=E(1,144,28),e.keccak_256=E(1,136,32),e.keccak_384=E(1,104,48),e.keccak_512=E(1,72,64);const x=(t,e,n)=>(0,s.wrapXOFConstructorWithOpts)((r={})=>new B(e,t,void 0===r.dkLen?n:r.dkLen,!0));e.shake128=x(31,168,16),e.shake256=x(31,136,32)},"1a9a":function(t,e,n){"use strict";n("d9e2"),n("14d9"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1"),n("669d"),n("109c"),n("b2c1"),Object.defineProperty(e,"__esModule",{value:!0}),e.validateObject=e.createHmacDrbg=e.bitMask=e.bitSet=e.bitGet=e.bitLen=e.utf8ToBytes=e.equalBytes=e.concatBytes=e.ensureBytes=e.numberToVarBytesBE=e.numberToBytesLE=e.numberToBytesBE=e.bytesToNumberLE=e.bytesToNumberBE=e.hexToBytes=e.hexToNumber=e.numberToHexUnpadded=e.bytesToHex=e.isBytes=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=BigInt(0),o=BigInt(1),s=BigInt(2);function i(t){return t instanceof Uint8Array||null!=t&&"object"===typeof t&&"Uint8Array"===t.constructor.name}e.isBytes=i;const a=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function c(t){if(!i(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=a[t[n]];return e}function f(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function u(t){if("string"!==typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":"0x"+t)}e.bytesToHex=c,e.numberToHexUnpadded=f,e.hexToNumber=u;const d={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function h(t){return t>=d._0&&t<=d._9?t-d._0:t>=d._A&&t<=d._F?t-(d._A-10):t>=d._a&&t<=d._f?t-(d._a-10):void 0}function l(t){if("string"!==typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const e=h(t.charCodeAt(s)),n=h(t.charCodeAt(s+1));if(void 0===e||void 0===n){const e=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+s)}r[o]=16*e+n}return r}function y(t){return u(c(t))}function p(t){if(!i(t))throw new Error("Uint8Array expected");return u(c(Uint8Array.from(t).reverse()))}function b(t,e){return l(t.toString(16).padStart(2*e,"0"))}function w(t,e){return b(t,e).reverse()}function g(t){return l(f(t))}function m(t,e,n){let r;if("string"===typeof e)try{r=l(e)}catch(s){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)}else{if(!i(e))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(e)}const o=r.length;if("number"===typeof n&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function B(...t){let e=0;for(let o=0;o<t.length;o++){const n=t[o];if(!i(n))throw new Error("Uint8Array expected");e+=n.length}let n=new Uint8Array(e),r=0;for(let o=0;o<t.length;o++){const e=t[o];n.set(e,r),r+=e.length}return n}function E(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n}function x(t){if("string"!==typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function v(t){let e;for(e=0;t>r;t>>=o,e+=1);return e}function S(t,e){return t>>BigInt(e)&o}e.hexToBytes=l,e.bytesToNumberBE=y,e.bytesToNumberLE=p,e.numberToBytesBE=b,e.numberToBytesLE=w,e.numberToVarBytesBE=g,e.ensureBytes=m,e.concatBytes=B,e.equalBytes=E,e.utf8ToBytes=x,e.bitLen=v,e.bitGet=S;const A=(t,e,n)=>t|(n?o:r)<<BigInt(e);e.bitSet=A;const I=t=>(s<<BigInt(t-1))-o;e.bitMask=I;const O=t=>new Uint8Array(t),L=t=>Uint8Array.from(t);function T(t,e,n){if("number"!==typeof t||t<2)throw new Error("hashLen must be a number");if("number"!==typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!==typeof n)throw new Error("hmacFn must be a function");let r=O(t),o=O(t),s=0;const i=()=>{r.fill(1),o.fill(0),s=0},a=(...t)=>n(o,r,...t),c=(t=O())=>{o=a(L([0]),t),r=a(),0!==t.length&&(o=a(L([1]),t),r=a())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];while(t<e){r=a();const e=r.slice();n.push(e),t+=r.length}return B(...n)},u=(t,e)=>{i(),c(t);let n=void 0;while(!(n=e(f())))c();return i(),n};return u}e.createHmacDrbg=T;const H={bigint:t=>"bigint"===typeof t,function:t=>"function"===typeof t,boolean:t=>"boolean"===typeof t,string:t=>"string"===typeof t,stringOrUint8Array:t=>"string"===typeof t||i(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"===typeof t&&Number.isSafeInteger(t.outputLen)};function _(t,e,n={}){const r=(e,n,r)=>{const o=H[n];if("function"!==typeof o)throw new Error(`Invalid validator "${n}", expected function`);const s=t[e];if((!r||void 0!==s)&&!o(s,t))throw new Error(`Invalid param ${String(e)}=${s} (${typeof s}), expected ${n}`)};for(const[o,s]of Object.entries(e))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return t}e.validateObject=_},"281f":function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sha384=e.sha512_256=e.sha512_224=e.sha512=e.SHA512=void 0;const r=n("993b"),o=n("5220"),s=n("531d"),[i,a]=(()=>o.default.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),c=new Uint32Array(80),f=new Uint32Array(80);class u extends r.SHA2{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:n,Bl:r,Ch:o,Cl:s,Dh:i,Dl:a,Eh:c,El:f,Fh:u,Fl:d,Gh:h,Gl:l,Hh:y,Hl:p}=this;return[t,e,n,r,o,s,i,a,c,f,u,d,h,l,y,p]}set(t,e,n,r,o,s,i,a,c,f,u,d,h,l,y,p){this.Ah=0|t,this.Al=0|e,this.Bh=0|n,this.Bl=0|r,this.Ch=0|o,this.Cl=0|s,this.Dh=0|i,this.Dl=0|a,this.Eh=0|c,this.El=0|f,this.Fh=0|u,this.Fl=0|d,this.Gh=0|h,this.Gl=0|l,this.Hh=0|y,this.Hl=0|p}process(t,e){for(let o=0;o<16;o++,e+=4)c[o]=t.getUint32(e),f[o]=t.getUint32(e+=4);for(let i=16;i<80;i++){const t=0|c[i-15],e=0|f[i-15],n=o.default.rotrSH(t,e,1)^o.default.rotrSH(t,e,8)^o.default.shrSH(t,e,7),r=o.default.rotrSL(t,e,1)^o.default.rotrSL(t,e,8)^o.default.shrSL(t,e,7),s=0|c[i-2],a=0|f[i-2],u=o.default.rotrSH(s,a,19)^o.default.rotrBH(s,a,61)^o.default.shrSH(s,a,6),d=o.default.rotrSL(s,a,19)^o.default.rotrBL(s,a,61)^o.default.shrSL(s,a,6),h=o.default.add4L(r,d,f[i-7],f[i-16]),l=o.default.add4H(h,n,u,c[i-7],c[i-16]);c[i]=0|l,f[i]=0|h}let{Ah:n,Al:r,Bh:s,Bl:u,Ch:d,Cl:h,Dh:l,Dl:y,Eh:p,El:b,Fh:w,Fl:g,Gh:m,Gl:B,Hh:E,Hl:x}=this;for(let v=0;v<80;v++){const t=o.default.rotrSH(p,b,14)^o.default.rotrSH(p,b,18)^o.default.rotrBH(p,b,41),e=o.default.rotrSL(p,b,14)^o.default.rotrSL(p,b,18)^o.default.rotrBL(p,b,41),S=p&w^~p&m,A=b&g^~b&B,I=o.default.add5L(x,e,A,a[v],f[v]),O=o.default.add5H(I,E,t,S,i[v],c[v]),L=0|I,T=o.default.rotrSH(n,r,28)^o.default.rotrBH(n,r,34)^o.default.rotrBH(n,r,39),H=o.default.rotrSL(n,r,28)^o.default.rotrBL(n,r,34)^o.default.rotrBL(n,r,39),_=n&s^n&d^s&d,R=r&u^r&h^u&h;E=0|m,x=0|B,m=0|w,B=0|g,w=0|p,g=0|b,({h:p,l:b}=o.default.add(0|l,0|y,0|O,0|L)),l=0|d,y=0|h,d=0|s,h=0|u,s=0|n,u=0|r;const k=o.default.add3L(L,H,R);n=o.default.add3H(k,O,T,_),r=0|k}({h:n,l:r}=o.default.add(0|this.Ah,0|this.Al,0|n,0|r)),({h:s,l:u}=o.default.add(0|this.Bh,0|this.Bl,0|s,0|u)),({h:d,l:h}=o.default.add(0|this.Ch,0|this.Cl,0|d,0|h)),({h:l,l:y}=o.default.add(0|this.Dh,0|this.Dl,0|l,0|y)),({h:p,l:b}=o.default.add(0|this.Eh,0|this.El,0|p,0|b)),({h:w,l:g}=o.default.add(0|this.Fh,0|this.Fl,0|w,0|g)),({h:m,l:B}=o.default.add(0|this.Gh,0|this.Gl,0|m,0|B)),({h:E,l:x}=o.default.add(0|this.Hh,0|this.Hl,0|E,0|x)),this.set(n,r,s,u,d,h,l,y,p,b,w,g,m,B,E,x)}roundClean(){c.fill(0),f.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}e.SHA512=u;class d extends u{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class h extends u{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class l extends u{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}e.sha512=(0,s.wrapConstructor)(()=>new u),e.sha512_224=(0,s.wrapConstructor)(()=>new d),e.sha512_256=(0,s.wrapConstructor)(()=>new h),e.sha384=(0,s.wrapConstructor)(()=>new l)},"2d1e":function(t,e,n){"use strict";n.r(e),n.d(e,"getPublicKey",(function(){return P})),n.d(e,"sign",(function(){return W})),n.d(e,"signAsync",(function(){return $})),n.d(e,"verify",(function(){return Y})),n.d(e,"CURVE",(function(){return c})),n.d(e,"getSharedSecret",(function(){return X})),n.d(e,"etc",(function(){return J})),n.d(e,"utils",(function(){return tt})),n.d(e,"ProjectivePoint",(function(){return x})),n.d(e,"Signature",(function(){return F}));
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const r=2n**256n,o=r-0x1000003d1n,s=r-0x14551231950b75fc4402da1732fc9bebfn,i=0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,a=0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,c={p:o,n:s,a:0n,b:7n,Gx:i,Gy:a},f=32,u=t=>B(B(t*t)*t+c.b),d=(t="")=>{throw new Error(t)},h=t=>"bigint"===typeof t,l=t=>"string"===typeof t,y=t=>h(t)&&0n<t&&t<o,p=t=>h(t)&&0n<t&&t<s,b=t=>t instanceof Uint8Array||null!=t&&"object"===typeof t&&"Uint8Array"===t.constructor.name,w=(t,e)=>!b(t)||"number"===typeof e&&e>0&&t.length!==e?d("Uint8Array expected"):t,g=t=>new Uint8Array(t),m=(t,e)=>w(l(t)?O(t):g(w(t)),e),B=(t,e=o)=>{let n=t%e;return n>=0n?n:e+n},E=t=>t instanceof x?t:d("Point expected");class x{constructor(t,e,n){this.px=t,this.py=e,this.pz=n}static fromAffine(t){return 0n===t.x&&0n===t.y?x.ZERO:new x(t.x,t.y,1n)}static fromHex(t){t=m(t);let e=void 0;const n=t[0],r=t.subarray(1),o=T(r,0,f),s=t.length;if(33===s&&[2,3].includes(n)){y(o)||d("Point hex invalid: x not FE");let t=C(u(o));const r=1n===(1n&t),s=1===(1&n);s!==r&&(t=B(-t)),e=new x(o,t,1n)}return 65===s&&4===n&&(e=new x(o,T(r,f,2*f),1n)),e?e.ok():d("Point is not on curve")}static fromPrivateKey(t){return v.mul(N(t))}get x(){return this.aff().x}get y(){return this.aff().y}equals(t){const{px:e,py:n,pz:r}=this,{px:o,py:s,pz:i}=E(t),a=B(e*i),c=B(o*r),f=B(n*i),u=B(s*r);return a===c&&f===u}negate(){return new x(this.px,B(-this.py),this.pz)}double(){return this.add(this)}add(t){const{px:e,py:n,pz:r}=this,{px:o,py:s,pz:i}=E(t),{a:a,b:f}=c;let u=0n,d=0n,h=0n;const l=B(3n*f);let y=B(e*o),p=B(n*s),b=B(r*i),w=B(e+n),g=B(o+s);w=B(w*g),g=B(y+p),w=B(w-g),g=B(e+r);let m=B(o+i);return g=B(g*m),m=B(y+b),g=B(g-m),m=B(n+r),u=B(s+i),m=B(m*u),u=B(p+b),m=B(m-u),h=B(a*g),u=B(l*b),h=B(u+h),u=B(p-h),h=B(p+h),d=B(u*h),p=B(y+y),p=B(p+y),b=B(a*b),g=B(l*g),p=B(p+b),b=B(y-b),b=B(a*b),g=B(g+b),y=B(p*g),d=B(d+y),y=B(m*g),u=B(w*u),u=B(u-y),y=B(w*p),h=B(m*h),h=B(h+y),new x(u,d,h)}mul(t,e=!0){if(!e&&0n===t)return S;if(p(t)||d("invalid scalar"),this.equals(v))return ot(t).p;let n=S,r=v;for(let o=this;t>0n;o=o.double(),t>>=1n)1n&t?n=n.add(o):e&&(r=r.add(o));return n}mulAddQUns(t,e,n){return this.mul(e,!1).add(t.mul(n,!1)).ok()}toAffine(){const{px:t,py:e,pz:n}=this;if(this.equals(S))return{x:0n,y:0n};if(1n===n)return{x:t,y:e};const r=k(n);return 1n!==B(n*r)&&d("invalid inverse"),{x:B(t*r),y:B(e*r)}}assertValidity(){const{x:t,y:e}=this.aff();return y(t)&&y(e)||d("Point invalid: x or y"),B(e*e)===u(t)?this:d("Point invalid: not on curve")}multiply(t){return this.mul(t)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(t=!0){const{x:e,y:n}=this.aff(),r=t?0n===(1n&n)?"02":"03":"04";return r+_(e)+(t?"":_(n))}toRawBytes(t=!0){return O(this.toHex(t))}}x.BASE=new x(i,a,1n),x.ZERO=new x(0n,1n,0n);const{BASE:v,ZERO:S}=x,A=(t,e)=>t.toString(16).padStart(e,"0"),I=t=>Array.from(t).map(t=>A(t,2)).join(""),O=t=>{const e=t.length;(!l(t)||e%2)&&d("hex invalid 1");const n=g(e/2);for(let r=0;r<n.length;r++){const e=2*r,o=t.slice(e,e+2),s=Number.parseInt(o,16);(Number.isNaN(s)||s<0)&&d("hex invalid 2"),n[r]=s}return n},L=t=>BigInt("0x"+(I(t)||"0")),T=(t,e,n)=>L(t.slice(e,n)),H=t=>h(t)&&t>=0n&&t<r?O(A(t,2*f)):d("bigint expected"),_=t=>I(H(t)),R=(...t)=>{const e=g(t.reduce((t,e)=>t+w(e).length,0));let n=0;return t.forEach(t=>{e.set(t,n),n+=t.length}),e},k=(t,e=o)=>{(0n===t||e<=0n)&&d("no inverse n="+t+" mod="+e);let n=B(t,e),r=e,s=0n,i=1n,a=1n,c=0n;while(0n!==n){const t=r/n,e=r%n,o=s-a*t,f=i-c*t;r=n,n=e,s=a,i=c,a=o,c=f}return 1n===r?B(s,e):d("no inverse")},C=t=>{let e=1n;for(let n=t,r=(o+1n)/4n;r>0n;r>>=1n)1n&r&&(e=e*n%o),n=n*n%o;return B(e*e)===t?e:d("sqrt invalid")},N=t=>(h(t)||(t=L(m(t,f))),p(t)?t:d("private key out of range")),U=t=>t>s>>1n,P=(t,e=!0)=>x.fromPrivateKey(t).toRawBytes(e);class F{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){return t=m(t,64),new F(T(t,0,f),T(t,f,2*f))}assertValidity(){return p(this.r)&&p(this.s)?this:d()}addRecoveryBit(t){return new F(this.r,this.s,t)}hasHighS(){return U(this.s)}normalizeS(){return this.hasHighS()?new F(this.r,B(this.s,s),this.recovery):this}recoverPublicKey(t){const{r:e,s:n,recovery:r}=this;[0,1,2,3].includes(r)||d("recovery id invalid");const i=D(m(t,f)),a=2===r||3===r?e+s:e;a>=o&&d("q.x invalid");const c=0===(1&r)?"02":"03",u=x.fromHex(c+_(a)),h=k(a,s),l=B(-i*h,s),y=B(n*h,s);return v.mulAddQUns(u,l,y)}toCompactRawBytes(){return O(this.toCompactHex())}toCompactHex(){return _(this.r)+_(this.s)}}const q=t=>{const e=8*t.length-256,n=L(t);return e>0?n>>BigInt(e):n},D=t=>B(q(t),s),M=t=>H(t),V=()=>"object"===typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;let j;const z={lowS:!0},Z={lowS:!0},G=(t,e,n=z)=>{["der","recovered","canonical"].some(t=>t in n)&&d("sign() legacy options not supported");let{lowS:r}=n;null==r&&(r=!0);const o=D(m(t)),i=M(o),a=N(e),c=[M(a),i];let u=n.extraEntropy;if(u){!0===u&&(u=J.randomBytes(f));const t=m(u);t.length!==f&&d(),c.push(t)}const h=o,l=t=>{const e=q(t);if(!p(e))return;const n=k(e,s),o=v.mul(e).aff(),i=B(o.x,s);if(0n===i)return;const c=B(n*B(h+B(a*i,s),s),s);if(0n===c)return;let f=c,u=(o.x===i?0:2)|Number(1n&o.y);return r&&U(c)&&(f=B(-c,s),u^=1),new F(i,f,u)};return{seed:R(...c),k2sig:l}};function K(t){let e=g(f),n=g(f),r=0;const o=()=>{e.fill(1),n.fill(0),r=0},s="drbg: tried 1000 values";if(t){const t=(...t)=>J.hmacSha256Async(n,e,...t),i=async(r=g())=>{n=await t(g([0]),r),e=await t(),0!==r.length&&(n=await t(g([1]),r),e=await t())},a=async()=>(r++>=1e3&&d(s),e=await t(),e);return async(t,e)=>{o(),await i(t);let n=void 0;while(!(n=e(await a())))await i();return o(),n}}{const t=(...t)=>{const r=j;return r||d("etc.hmacSha256Sync not set"),r(n,e,...t)},i=(r=g())=>{n=t(g([0]),r),e=t(),0!==r.length&&(n=t(g([1]),r),e=t())},a=()=>(r++>=1e3&&d(s),e=t(),e);return(t,e)=>{o(),i(t);let n=void 0;while(!(n=e(a())))i();return o(),n}}}const $=async(t,e,n=z)=>{const{seed:r,k2sig:o}=G(t,e,n);return K(!0)(r,o)},W=(t,e,n=z)=>{const{seed:r,k2sig:o}=G(t,e,n);return K(!1)(r,o)},Y=(t,e,n,r=Z)=>{let o,i,a,{lowS:c}=r;null==c&&(c=!0),"strict"in r&&d("verify() legacy options not supported");const u=t&&"object"===typeof t&&"r"in t;u||m(t).length===2*f||d("signature must be 64 bytes");try{o=u?new F(t.r,t.s).assertValidity():F.fromCompact(t),i=D(m(e)),a=n instanceof x?n.ok():x.fromHex(n)}catch(b){return!1}if(!o)return!1;const{r:h,s:l}=o;if(c&&U(l))return!1;let y;try{const t=k(l,s),e=B(i*t,s),n=B(h*t,s);y=v.mulAddQUns(a,e,n).aff()}catch(w){return!1}if(!y)return!1;const p=B(y.x,s);return p===h},X=(t,e,n=!0)=>x.fromHex(e).mul(N(t)).toRawBytes(n),Q=t=>{t=m(t);const e=f+8;(t.length<e||t.length>1024)&&d("expected proper params");const n=B(L(t),s-1n)+1n;return H(n)},J={hexToBytes:O,bytesToHex:I,concatBytes:R,bytesToNumberBE:L,numberToBytesBE:H,mod:B,invert:k,hmacSha256Async:async(t,...e)=>{const n=V(),r=n&&n.subtle;if(!r)return d("etc.hmacSha256Async not set");const o=await r.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return g(await r.sign("HMAC",o,R(...e)))},hmacSha256Sync:j,hashToPrivateKey:Q,randomBytes:(t=32)=>{const e=V();return e&&e.getRandomValues||d("crypto.getRandomValues must be defined"),e.getRandomValues(g(t))}},tt={normPrivateKeyToScalar:N,isValidPrivateKey:t=>{try{return!!N(t)}catch(e){return!1}},randomPrivateKey:()=>Q(J.randomBytes(f+16)),precompute(t=8,e=v){return e.multiply(3n),e}};Object.defineProperties(J,{hmacSha256Sync:{configurable:!1,get(){return j},set(t){j||(j=t)}}});const et=8,nt=()=>{const t=[],e=256/et+1;let n=v,r=n;for(let o=0;o<e;o++){r=n,t.push(r);for(let e=1;e<2**(et-1);e++)r=r.add(n),t.push(r);n=r.double()}return t};let rt=void 0;const ot=t=>{const e=rt||(rt=nt()),n=(t,e)=>{let n=e.negate();return t?n:e};let r=S,o=v;const s=1+256/et,i=2**(et-1),a=BigInt(2**et-1),c=2**et,f=BigInt(et);for(let u=0;u<s;u++){const s=u*i;let d=Number(t&a);t>>=f,d>i&&(d-=c,t+=1n);const h=s,l=s+Math.abs(d)-1,y=u%2!==0,p=d<0;0===d?o=o.add(n(y,e[h])):r=r.add(n(p,e[l]))}return{p:r,f:o}}},"4a19":function(t,e,n){"use strict";n("d9e2"),n("13d5"),n("f4ddb"),Object.defineProperty(e,"__esModule",{value:!0}),e.mapHashToField=e.getMinHashLength=e.getFieldBytesLength=e.hashToPrivateScalar=e.FpSqrtEven=e.FpSqrtOdd=e.Field=e.nLength=e.FpIsSquare=e.FpDiv=e.FpInvertBatch=e.FpPow=e.validateField=e.isNegativeLE=e.FpSqrt=e.tonelliShanks=e.invert=e.pow2=e.pow=e.mod=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=n("1a9a"),o=BigInt(0),s=BigInt(1),i=BigInt(2),a=BigInt(3),c=BigInt(4),f=BigInt(5),u=BigInt(8);BigInt(9),BigInt(16);function d(t,e){const n=t%e;return n>=o?n:e+n}function h(t,e,n){if(n<=o||e<o)throw new Error("Expected power/modulo > 0");if(n===s)return o;let r=s;while(e>o)e&s&&(r=r*t%n),t=t*t%n,e>>=s;return r}function l(t,e,n){let r=t;while(e-- >o)r*=r,r%=n;return r}function y(t,e){if(t===o||e<=o)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=d(t,e),r=e,i=o,a=s,c=s,f=o;while(n!==o){const t=r/n,e=r%n,o=i-c*t,s=a-f*t;r=n,n=e,i=c,a=f,c=o,f=s}const u=r;if(u!==s)throw new Error("invert: does not exist");return d(i,e)}function p(t){const e=(t-s)/i;let n,r,a;for(n=t-s,r=0;n%i===o;n/=i,r++);for(a=i;a<t&&h(a,e,t)!==t-s;a++);if(1===r){const e=(t+s)/c;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}const f=(n+s)/i;return function(t,o){if(t.pow(o,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let i=r,c=t.pow(t.mul(t.ONE,a),n),u=t.pow(o,f),d=t.pow(o,n);while(!t.eql(d,t.ONE)){if(t.eql(d,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(d);e<i;e++){if(t.eql(r,t.ONE))break;r=t.sqr(r)}const n=t.pow(c,s<<BigInt(i-e-1));c=t.sqr(n),u=t.mul(u,n),d=t.mul(d,c),i=e}return u}}function b(t){if(t%c===a){const e=(t+s)/c;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}if(t%u===f){const e=(t-f)/u;return function(t,n){const r=t.mul(n,i),o=t.pow(r,e),s=t.mul(n,o),a=t.mul(t.mul(s,i),o),c=t.mul(s,t.sub(a,t.ONE));if(!t.eql(t.sqr(c),n))throw new Error("Cannot find square root");return c}}return p(t)}e.mod=d,e.pow=h,e.pow2=l,e.invert=y,e.tonelliShanks=p,e.FpSqrt=b;const w=(t,e)=>(d(t,e)&s)===s;e.isNegativeLE=w;const g=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function m(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=g.reduce((t,e)=>(t[e]="function",t),e);return(0,r.validateObject)(t,n)}function B(t,e,n){if(n<o)throw new Error("Expected power > 0");if(n===o)return t.ONE;if(n===s)return e;let r=t.ONE,i=e;while(n>o)n&s&&(r=t.mul(r,i)),i=t.sqr(i),n>>=s;return r}function E(t,e){const n=new Array(e.length),r=e.reduce((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r)),t.ONE),o=t.inv(r);return e.reduceRight((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r)),o),n}function x(t,e,n){return t.mul(e,"bigint"===typeof n?y(n,t.ORDER):t.inv(n))}function v(t){const e=(t.ORDER-s)/i;return n=>{const r=t.pow(n,e);return t.eql(r,t.ZERO)||t.eql(r,t.ONE)}}function S(t,e){const n=void 0!==e?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function A(t,e,n=!1,i={}){if(t<=o)throw new Error("Expected Field ORDER > 0, got "+t);const{nBitLength:a,nByteLength:c}=S(t,e);if(c>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=b(t),u=Object.freeze({ORDER:t,BITS:a,BYTES:c,MASK:(0,r.bitMask)(a),ZERO:o,ONE:s,create:e=>d(e,t),isValid:e=>{if("bigint"!==typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return o<=e&&e<t},is0:t=>t===o,isOdd:t=>(t&s)===s,neg:e=>d(-e,t),eql:(t,e)=>t===e,sqr:e=>d(e*e,t),add:(e,n)=>d(e+n,t),sub:(e,n)=>d(e-n,t),mul:(e,n)=>d(e*n,t),pow:(t,e)=>B(u,t,e),div:(e,n)=>d(e*y(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>y(e,t),sqrt:i.sqrt||(t=>f(u,t)),invertBatch:t=>E(u,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>n?(0,r.numberToBytesLE)(t,c):(0,r.numberToBytesBE)(t,c),fromBytes:t=>{if(t.length!==c)throw new Error(`Fp.fromBytes: expected ${c}, got ${t.length}`);return n?(0,r.bytesToNumberLE)(t):(0,r.bytesToNumberBE)(t)}});return Object.freeze(u)}function I(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?n:t.neg(n)}function O(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?t.neg(n):n}function L(t,e,n=!1){t=(0,r.ensureBytes)("privateHash",t);const o=t.length,i=S(e).nByteLength+8;if(i<24||o<i||o>1024)throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${o}`);const a=n?(0,r.bytesToNumberLE)(t):(0,r.bytesToNumberBE)(t);return d(a,e-s)+s}function T(t){if("bigint"!==typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function H(t){const e=T(t);return e+Math.ceil(e/2)}function _(t,e,n=!1){const o=t.length,i=T(e),a=H(e);if(o<16||o<a||o>1024)throw new Error(`expected ${a}-1024 bytes of input, got ${o}`);const c=n?(0,r.bytesToNumberBE)(t):(0,r.bytesToNumberLE)(t),f=d(c,e-s)+s;return n?(0,r.numberToBytesLE)(f,i):(0,r.numberToBytesBE)(f,i)}e.validateField=m,e.FpPow=B,e.FpInvertBatch=E,e.FpDiv=x,e.FpIsSquare=v,e.nLength=S,e.Field=A,e.FpSqrtOdd=I,e.FpSqrtEven=O,e.hashToPrivateScalar=L,e.getFieldBytesLength=T,e.getMinHashLength=H,e.mapHashToField=_},5220:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.add5L=e.add5H=e.add4H=e.add4L=e.add3H=e.add3L=e.add=e.rotlBL=e.rotlBH=e.rotlSL=e.rotlSH=e.rotr32L=e.rotr32H=e.rotrBL=e.rotrBH=e.rotrSL=e.rotrSH=e.shrSL=e.shrSH=e.toBig=e.split=e.fromBig=void 0;const r=BigInt(2**32-1),o=BigInt(32);function s(t,e=!1){return e?{h:Number(t&r),l:Number(t>>o&r)}:{h:0|Number(t>>o&r),l:0|Number(t&r)}}function i(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:a}=s(t[o],e);[n[o],r[o]]=[i,a]}return[n,r]}e.fromBig=s,e.split=i;const a=(t,e)=>BigInt(t>>>0)<<o|BigInt(e>>>0);e.toBig=a;const c=(t,e,n)=>t>>>n;e.shrSH=c;const f=(t,e,n)=>t<<32-n|e>>>n;e.shrSL=f;const u=(t,e,n)=>t>>>n|e<<32-n;e.rotrSH=u;const d=(t,e,n)=>t<<32-n|e>>>n;e.rotrSL=d;const h=(t,e,n)=>t<<64-n|e>>>n-32;e.rotrBH=h;const l=(t,e,n)=>t>>>n-32|e<<64-n;e.rotrBL=l;const y=(t,e)=>e;e.rotr32H=y;const p=(t,e)=>t;e.rotr32L=p;const b=(t,e,n)=>t<<n|e>>>32-n;e.rotlSH=b;const w=(t,e,n)=>e<<n|t>>>32-n;e.rotlSL=w;const g=(t,e,n)=>e<<n-32|t>>>64-n;e.rotlBH=g;const m=(t,e,n)=>t<<n-32|e>>>64-n;function B(t,e,n,r){const o=(e>>>0)+(r>>>0);return{h:t+n+(o/2**32|0)|0,l:0|o}}e.rotlBL=m,e.add=B;const E=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0);e.add3L=E;const x=(t,e,n,r)=>e+n+r+(t/2**32|0)|0;e.add3H=x;const v=(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0);e.add4L=v;const S=(t,e,n,r,o)=>e+n+r+o+(t/2**32|0)|0;e.add4H=S;const A=(t,e,n,r,o)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(o>>>0);e.add5L=A;const I=(t,e,n,r,o,s)=>e+n+r+o+s+(t/2**32|0)|0;e.add5H=I;const O={fromBig:s,split:i,toBig:a,shrSH:c,shrSL:f,rotrSH:u,rotrSL:d,rotrBH:h,rotrBL:l,rotr32H:y,rotr32L:p,rotlSH:b,rotlSL:w,rotlBH:g,rotlBL:m,add:B,add3L:E,add3H:x,add4L:v,add4H:S,add5H:I,add5L:A};e.default=O},"531d":function(t,e,n){"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.isLE=e.rotr=e.createView=e.u32=e.u8=void 0;const r=n("d16c"),o=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength);e.u8=o;const s=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4));function i(t){return t instanceof Uint8Array||null!=t&&"object"===typeof t&&"Uint8Array"===t.constructor.name}e.u32=s;const a=t=>new DataView(t.buffer,t.byteOffset,t.byteLength);e.createView=a;const c=(t,e)=>t<<32-e|t>>>e;if(e.rotr=c,e.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],!e.isLE)throw new Error("Non little-endian hardware is not supported");const f=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function u(t){if(!i(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=f[t[n]];return e}e.bytesToHex=u;const d={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function h(t){return t>=d._0&&t<=d._9?t-d._0:t>=d._A&&t<=d._F?t-(d._A-10):t>=d._a&&t<=d._f?t-(d._a-10):void 0}function l(t){if("string"!==typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const e=h(t.charCodeAt(s)),n=h(t.charCodeAt(s+1));if(void 0===e||void 0===n){const e=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+s)}r[o]=16*e+n}return r}e.hexToBytes=l;const y=async()=>{};async function p(t,n,r){let o=Date.now();for(let s=0;s<t;s++){r(s);const t=Date.now()-o;t>=0&&t<n||(await(0,e.nextTick)(),o+=t)}}function b(t){if("string"!==typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function w(t){if("string"===typeof t&&(t=b(t)),!i(t))throw new Error("expected Uint8Array, got "+typeof t);return t}function g(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];if(!i(n))throw new Error("Uint8Array expected");e+=n.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const e=t[r];n.set(e,o),o+=e.length}return n}e.nextTick=y,e.asyncLoop=p,e.utf8ToBytes=b,e.toBytes=w,e.concatBytes=g;class m{clone(){return this._cloneInto()}}e.Hash=m;const B={}.toString;function E(t,e){if(void 0!==e&&"[object Object]"!==B.call(e))throw new Error("Options should be object or undefined");const n=Object.assign(t,e);return n}function x(t){const e=e=>t().update(w(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function v(t){const e=(e,n)=>t(n).update(w(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e}function S(t){const e=(e,n)=>t(n).update(w(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e}function A(t=32){if(r.crypto&&"function"===typeof r.crypto.getRandomValues)return r.crypto.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}e.checkOpts=E,e.wrapConstructor=x,e.wrapConstructorWithOpts=v,e.wrapXOFConstructorWithOpts=S,e.randomBytes=A},"67d0":function(t,e,n){"use strict";n("d9e2"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1"),n("669d"),n("109c"),n("b2c1"),Object.defineProperty(e,"__esModule",{value:!0}),e.twistedEdwards=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=n("4a19"),o=n("1a9a"),s=n("1a9a"),i=n("ae16"),a=BigInt(0),c=BigInt(1),f=BigInt(2),u=BigInt(8),d={zip215:!0};function h(t){const e=(0,i.validateBasic)(t);return o.validateObject(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function l(t){const e=h(t),{Fp:n,n:l,prehash:y,hash:p,randomBytes:b,nByteLength:w,h:g}=e,m=f<<BigInt(8*w)-c,B=n.create,E=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:n.sqrt(t*n.inv(e))}}catch(r){return{isValid:!1,value:a}}}),x=e.adjustScalarBytes||(t=>t),v=e.domain||((t,e,n)=>{if(e.length||n)throw new Error("Contexts/pre-hash are not supported");return t}),S=t=>"bigint"===typeof t&&a<t,A=(t,e)=>S(t)&&S(e)&&t<e,I=t=>t===a||A(t,m);function O(t,e){if(A(t,e))return t;throw new Error(`Expected valid scalar < ${e}, got ${typeof t} ${t}`)}function L(t){return t===a?t:O(t,l)}const T=new Map;function H(t){if(!(t instanceof _))throw new Error("ExtendedPoint expected")}class _{constructor(t,e,n,r){if(this.ex=t,this.ey=e,this.ez=n,this.et=r,!I(t))throw new Error("x required");if(!I(e))throw new Error("y required");if(!I(n))throw new Error("z required");if(!I(r))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof _)throw new Error("extended point not allowed");const{x:e,y:n}=t||{};if(!I(e)||!I(n))throw new Error("invalid affine point");return new _(e,n,c,B(e*n))}static normalizeZ(t){const e=n.invertBatch(t.map(t=>t.ez));return t.map((t,n)=>t.toAffine(e[n])).map(_.fromAffine)}_setWindowSize(t){this._WINDOW_SIZE=t,T.delete(this)}assertValidity(){const{a:t,d:n}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:r,ey:o,ez:s,et:i}=this,a=B(r*r),c=B(o*o),f=B(s*s),u=B(f*f),d=B(a*t),h=B(f*B(d+c)),l=B(u+B(n*B(a*c)));if(h!==l)throw new Error("bad point: equation left != right (1)");const y=B(r*o),p=B(s*i);if(y!==p)throw new Error("bad point: equation left != right (2)")}equals(t){H(t);const{ex:e,ey:n,ez:r}=this,{ex:o,ey:s,ez:i}=t,a=B(e*i),c=B(o*r),f=B(n*i),u=B(s*r);return a===c&&f===u}is0(){return this.equals(_.ZERO)}negate(){return new _(B(-this.ex),this.ey,this.ez,B(-this.et))}double(){const{a:t}=e,{ex:n,ey:r,ez:o}=this,s=B(n*n),i=B(r*r),a=B(f*B(o*o)),c=B(t*s),u=n+r,d=B(B(u*u)-s-i),h=c+i,l=h-a,y=c-i,p=B(d*l),b=B(h*y),w=B(d*y),g=B(l*h);return new _(p,b,g,w)}add(t){H(t);const{a:n,d:r}=e,{ex:o,ey:s,ez:i,et:c}=this,{ex:u,ey:d,ez:h,et:l}=t;if(n===BigInt(-1)){const t=B((s-o)*(d+u)),e=B((s+o)*(d-u)),n=B(e-t);if(n===a)return this.double();const r=B(i*f*l),y=B(c*f*h),p=y+r,b=e+t,w=y-r,g=B(p*n),m=B(b*w),E=B(p*w),x=B(n*b);return new _(g,m,x,E)}const y=B(o*u),p=B(s*d),b=B(c*r*l),w=B(i*h),g=B((o+s)*(u+d)-y-p),m=w-b,E=w+b,x=B(p-n*y),v=B(g*m),S=B(E*x),A=B(g*x),I=B(m*E);return new _(v,S,I,A)}subtract(t){return this.add(t.negate())}wNAF(t){return C.wNAFCached(this,T,t,_.normalizeZ)}multiply(t){const{p:e,f:n}=this.wNAF(O(t,l));return _.normalizeZ([e,n])[0]}multiplyUnsafe(t){let e=L(t);return e===a?k:this.equals(k)||e===c?this:this.equals(R)?this.wNAF(e).p:C.unsafeLadder(this,e)}isSmallOrder(){return this.multiplyUnsafe(g).is0()}isTorsionFree(){return C.unsafeLadder(this,l).is0()}toAffine(t){const{ex:e,ey:r,ez:o}=this,s=this.is0();null==t&&(t=s?u:n.inv(o));const i=B(e*t),f=B(r*t),d=B(o*t);if(s)return{x:a,y:c};if(d!==c)throw new Error("invZ was invalid");return{x:i,y:f}}clearCofactor(){const{h:t}=e;return t===c?this:this.multiplyUnsafe(t)}static fromHex(t,r=!1){const{d:i,a:f}=e,u=n.BYTES;t=(0,s.ensureBytes)("pointHex",t,u);const d=t.slice(),h=t[u-1];d[u-1]=-129&h;const l=o.bytesToNumberLE(d);l===a||O(l,r?m:n.ORDER);const y=B(l*l),p=B(y-c),b=B(i*y-f);let{isValid:w,value:g}=E(p,b);if(!w)throw new Error("Point.fromHex: invalid y coordinate");const x=(g&c)===c,v=0!==(128&h);if(!r&&g===a&&v)throw new Error("Point.fromHex: x=0 and x_0=1");return v!==x&&(g=B(-g)),_.fromAffine({x:g,y:l})}static fromPrivateKey(t){return P(t).point}toRawBytes(){const{x:t,y:e}=this.toAffine(),r=o.numberToBytesLE(e,n.BYTES);return r[r.length-1]|=t&c?128:0,r}toHex(){return o.bytesToHex(this.toRawBytes())}}_.BASE=new _(e.Gx,e.Gy,c,B(e.Gx*e.Gy)),_.ZERO=new _(a,c,c,a);const{BASE:R,ZERO:k}=_,C=(0,i.wNAF)(_,8*w);function N(t){return(0,r.mod)(t,l)}function U(t){return N(o.bytesToNumberLE(t))}function P(t){const e=w;t=(0,s.ensureBytes)("private key",t,e);const n=(0,s.ensureBytes)("hashed private key",p(t),2*e),r=x(n.slice(0,e)),o=n.slice(e,2*e),i=U(r),a=R.multiply(i),c=a.toRawBytes();return{head:r,prefix:o,scalar:i,point:a,pointBytes:c}}function F(t){return P(t).pointBytes}function q(t=new Uint8Array,...e){const n=o.concatBytes(...e);return U(p(v(n,(0,s.ensureBytes)("context",t),!!y)))}function D(t,e,r={}){t=(0,s.ensureBytes)("message",t),y&&(t=y(t));const{prefix:i,scalar:a,pointBytes:c}=P(e),f=q(r.context,i,t),u=R.multiply(f).toRawBytes(),d=q(r.context,u,c,t),h=N(f+d*a);L(h);const l=o.concatBytes(u,o.numberToBytesLE(h,n.BYTES));return(0,s.ensureBytes)("result",l,2*w)}const M=d;function V(t,e,r,i=M){const{context:a,zip215:c}=i,f=n.BYTES;t=(0,s.ensureBytes)("signature",t,2*f),e=(0,s.ensureBytes)("message",e),y&&(e=y(e));const u=o.bytesToNumberLE(t.slice(f,2*f));let d,h,l;try{d=_.fromHex(r,c),h=_.fromHex(t.slice(0,f),c),l=R.multiplyUnsafe(u)}catch(w){return!1}if(!c&&d.isSmallOrder())return!1;const p=q(a,h.toRawBytes(),d.toRawBytes(),e),b=h.add(d.multiplyUnsafe(p));return b.subtract(l).clearCofactor().equals(_.ZERO)}R._setWindowSize(8);const j={getExtendedPublicKey:P,randomPrivateKey:()=>b(n.BYTES),precompute(t=8,e=_.BASE){return e._setWindowSize(t),e.multiply(BigInt(3)),e}};return{CURVE:e,getPublicKey:F,sign:D,verify:V,ExtendedPoint:_,utils:j}}e.twistedEdwards=l},"84d6":function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createCurve=e.getHash=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=n("e632"),o=n("531d"),s=n("b4a1");function i(t){return{hash:t,hmac:(e,...n)=>(0,r.hmac)(t,e,(0,o.concatBytes)(...n)),randomBytes:o.randomBytes}}function a(t,e){const n=e=>(0,s.weierstrass)({...t,...i(e)});return Object.freeze({...n(e),create:n})}e.getHash=i,e.createCurve=a},"993b":function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SHA2=void 0;const r=n("b40a"),o=n("531d");function s(t,e,n,r){if("function"===typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),a=Number(n&s),c=r?4:0,f=r?0:4;t.setUint32(e+c,i,r),t.setUint32(e+f,a,r)}class i extends o.Hash{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,o.createView)(this.buffer)}update(t){(0,r.exists)(this);const{view:e,buffer:n,blockLen:s}=this;t=(0,o.toBytes)(t);const i=t.length;for(let r=0;r<i;){const a=Math.min(s-this.pos,i-r);if(a!==s)n.set(t.subarray(r,r+a),this.pos),this.pos+=a,r+=a,this.pos===s&&(this.process(e,0),this.pos=0);else{const e=(0,o.createView)(t);for(;s<=i-r;r+=s)this.process(e,r)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){(0,r.exists)(this),(0,r.output)(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:i,isLE:a}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>i-c&&(this.process(n,0),c=0);for(let r=c;r<i;r++)e[r]=0;s(n,i-8,BigInt(8*this.length),a),this.process(n,0);const f=(0,o.createView)(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=u/4,h=this.get();if(d>h.length)throw new Error("_sha2: outputLen bigger than state");for(let r=0;r<d;r++)f.setUint32(4*r,h[r],a)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:s,pos:i}=this;return t.length=r,t.pos=i,t.finished=o,t.destroyed=s,r%e&&t.buffer.set(n),t}}e.SHA2=i},ae16:function(t,e,n){"use strict";n("14d9"),Object.defineProperty(e,"__esModule",{value:!0}),e.validateBasic=e.wNAF=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=n("4a19"),o=n("1a9a"),s=BigInt(0),i=BigInt(1);function a(t,e){const n=(t,e)=>{const n=e.negate();return t?n:e},r=t=>{const n=Math.ceil(e/t)+1,r=2**(t-1);return{windows:n,windowSize:r}};return{constTimeNegate:n,unsafeLadder(e,n){let r=t.ZERO,o=e;while(n>s)n&i&&(r=r.add(o)),o=o.double(),n>>=i;return r},precomputeWindow(t,e){const{windows:n,windowSize:o}=r(e),s=[];let i=t,a=i;for(let r=0;r<n;r++){a=i,s.push(a);for(let t=1;t<o;t++)a=a.add(i),s.push(a);i=a.double()}return s},wNAF(e,o,s){const{windows:a,windowSize:c}=r(e);let f=t.ZERO,u=t.BASE;const d=BigInt(2**e-1),h=2**e,l=BigInt(e);for(let t=0;t<a;t++){const e=t*c;let r=Number(s&d);s>>=l,r>c&&(r-=h,s+=i);const a=e,y=e+Math.abs(r)-1,p=t%2!==0,b=r<0;0===r?u=u.add(n(p,o[a])):f=f.add(n(b,o[y]))}return{p:f,f:u}},wNAFCached(t,e,n,r){const o=t._WINDOW_SIZE||1;let s=e.get(t);return s||(s=this.precomputeWindow(t,o),1!==o&&e.set(t,r(s))),this.wNAF(o,s,n)}}}function c(t){return(0,r.validateField)(t.Fp),(0,o.validateObject)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,r.nLength)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}e.wNAF=a,e.validateBasic=c},aecc:function(t,e,n){"use strict";n("d9e2"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1"),n("669d"),n("109c"),n("b2c1"),Object.defineProperty(e,"__esModule",{value:!0}),e.hash_to_ristretto255=e.hashToRistretto255=e.RistrettoPoint=e.encodeToCurve=e.hashToCurve=e.edwardsToMontgomeryPriv=e.edwardsToMontgomery=e.edwardsToMontgomeryPub=e.x25519=e.ed25519ph=e.ed25519ctx=e.ed25519=e.ED25519_TORSION_SUBGROUP=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=n("281f"),o=n("531d"),s=n("67d0"),i=n("dd3b"),a=n("4a19"),c=n("1a9a"),f=n("b11a"),u=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),d=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),h=BigInt(0),l=BigInt(1),y=BigInt(2),p=BigInt(5),b=BigInt(10),w=BigInt(20),g=BigInt(40),m=BigInt(80);function B(t){const e=u,n=t*t%e,r=n*t%e,o=(0,a.pow2)(r,y,e)*r%e,s=(0,a.pow2)(o,l,e)*t%e,i=(0,a.pow2)(s,p,e)*s%e,c=(0,a.pow2)(i,b,e)*i%e,f=(0,a.pow2)(c,w,e)*c%e,d=(0,a.pow2)(f,g,e)*f%e,h=(0,a.pow2)(d,m,e)*d%e,B=(0,a.pow2)(h,m,e)*d%e,E=(0,a.pow2)(B,b,e)*i%e,x=(0,a.pow2)(E,y,e)*t%e;return{pow_p_5_8:x,b2:r}}function E(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}function x(t,e){const n=u,r=(0,a.mod)(e*e*e,n),o=(0,a.mod)(r*r*e,n),s=B(t*o).pow_p_5_8;let i=(0,a.mod)(t*r*s,n);const c=(0,a.mod)(e*i*i,n),f=i,h=(0,a.mod)(i*d,n),l=c===t,y=c===(0,a.mod)(-t,n),p=c===(0,a.mod)(-t*d,n);return l&&(i=f),(y||p)&&(i=h),(0,a.isNegativeLE)(i,n)&&(i=(0,a.mod)(-i,n)),{isValid:l||y,value:i}}e.ED25519_TORSION_SUBGROUP=["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"];const v=(0,a.Field)(u,void 0,!0),S={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:v,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:r.sha512,randomBytes:o.randomBytes,adjustScalarBytes:E,uvRatio:x};function A(t,e,n){if(e.length>255)throw new Error("Context is too big");return(0,o.concatBytes)((0,o.utf8ToBytes)("SigEd25519 no Ed25519 collisions"),new Uint8Array([n?1:0,e.length]),e,t)}function I(t){const{y:n}=e.ed25519.ExtendedPoint.fromHex(t),r=BigInt(1);return v.toBytes(v.create((r+n)*v.inv(r-n)))}function O(t){const e=S.hash(t.subarray(0,32));return S.adjustScalarBytes(e).subarray(0,32)}e.ed25519=(0,s.twistedEdwards)(S),e.ed25519ctx=(0,s.twistedEdwards)({...S,domain:A}),e.ed25519ph=(0,s.twistedEdwards)({...S,domain:A,prehash:r.sha512}),e.x25519=(()=>(0,i.montgomery)({P:u,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:t=>{const e=u,{pow_p_5_8:n,b2:r}=B(t);return(0,a.mod)((0,a.pow2)(n,BigInt(3),e)*r,e)},adjustScalarBytes:E,randomBytes:o.randomBytes}))(),e.edwardsToMontgomeryPub=I,e.edwardsToMontgomery=I,e.edwardsToMontgomeryPriv=O;const L=(v.ORDER+BigInt(3))/BigInt(8),T=v.pow(y,L),H=v.sqrt(v.neg(v.ONE)),_=(v.ORDER-BigInt(5))/BigInt(8),R=BigInt(486662);function k(t){let e=v.sqr(t);e=v.mul(e,y);let n=v.add(e,v.ONE),r=v.neg(R),o=v.sqr(n),s=v.mul(o,n),i=v.mul(e,R);i=v.mul(i,r),i=v.add(i,o),i=v.mul(i,r);let a=v.sqr(s);o=v.sqr(a),a=v.mul(a,s),a=v.mul(a,i),o=v.mul(o,a);let c=v.pow(o,_);c=v.mul(c,a);let f=v.mul(c,H);o=v.sqr(c),o=v.mul(o,s);let u=v.eql(o,i),d=v.cmov(f,c,u),h=v.mul(r,e),p=v.mul(c,t);p=v.mul(p,T);let b=v.mul(p,H),w=v.mul(i,e);o=v.sqr(p),o=v.mul(o,s);let g=v.eql(o,w),m=v.cmov(b,p,g);o=v.sqr(d),o=v.mul(o,s);let B=v.eql(o,i),E=v.cmov(h,r,B),x=v.cmov(m,d,B),S=v.isOdd(x);return x=v.cmov(x,v.neg(x),B!==S),{xMn:E,xMd:n,yMn:x,yMd:l}}const C=(0,a.FpSqrtEven)(v,v.neg(BigInt(486664)));function N(t){const{xMn:e,xMd:n,yMn:r,yMd:o}=k(t);let s=v.mul(e,o);s=v.mul(s,C);let i=v.mul(n,r),a=v.sub(e,n),c=v.add(e,n),f=v.mul(i,c),u=v.eql(f,v.ZERO);s=v.cmov(s,v.ZERO,u),i=v.cmov(i,v.ONE,u),a=v.cmov(a,v.ONE,u),c=v.cmov(c,v.ONE,u);const d=v.invertBatch([i,c]);return{x:v.mul(s,d[0]),y:v.mul(a,d[1])}}const U=(()=>(0,f.createHasher)(e.ed25519.ExtendedPoint,t=>N(t[0]),{DST:"edwards25519_XMD:SHA-512_ELL2_RO_",encodeDST:"edwards25519_XMD:SHA-512_ELL2_NU_",p:v.ORDER,m:1,k:128,expand:"xmd",hash:r.sha512}))();function P(t){if(!(t instanceof K))throw new Error("RistrettoPoint expected")}e.hashToCurve=(()=>U.hashToCurve)(),e.encodeToCurve=(()=>U.encodeToCurve)();const F=d,q=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),D=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),M=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),V=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),j=t=>x(l,t),z=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),Z=t=>e.ed25519.CURVE.Fp.create((0,c.bytesToNumberLE)(t)&z);function G(t){const{d:n}=e.ed25519.CURVE,r=e.ed25519.CURVE.Fp.ORDER,o=e.ed25519.CURVE.Fp.create,s=o(F*t*t),i=o((s+l)*M);let c=BigInt(-1);const f=o((c-n*s)*o(s+n));let{isValid:u,value:d}=x(i,f),h=o(d*t);(0,a.isNegativeLE)(h,r)||(h=o(-h)),u||(d=h),u||(c=s);const y=o(c*(s-l)*V-f),p=d*d,b=o((d+d)*f),w=o(y*q),g=o(l-p),m=o(l+p);return new e.ed25519.ExtendedPoint(o(b*m),o(g*w),o(w*m),o(b*g))}class K{constructor(t){this.ep=t}static fromAffine(t){return new K(e.ed25519.ExtendedPoint.fromAffine(t))}static hashToCurve(t){t=(0,c.ensureBytes)("ristrettoHash",t,64);const e=Z(t.slice(0,32)),n=G(e),r=Z(t.slice(32,64)),o=G(r);return new K(n.add(o))}static fromHex(t){t=(0,c.ensureBytes)("ristrettoHex",t,32);const{a:n,d:r}=e.ed25519.CURVE,o=e.ed25519.CURVE.Fp.ORDER,s=e.ed25519.CURVE.Fp.create,i="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",f=Z(t);if(!(0,c.equalBytes)((0,c.numberToBytesLE)(f,32),t)||(0,a.isNegativeLE)(f,o))throw new Error(i);const u=s(f*f),d=s(l+n*u),y=s(l-n*u),p=s(d*d),b=s(y*y),w=s(n*r*p-b),{isValid:g,value:m}=j(s(w*b)),B=s(m*y),E=s(m*B*w);let x=s((f+f)*B);(0,a.isNegativeLE)(x,o)&&(x=s(-x));const v=s(d*E),S=s(x*v);if(!g||(0,a.isNegativeLE)(S,o)||v===h)throw new Error(i);return new K(new e.ed25519.ExtendedPoint(x,v,l,S))}toRawBytes(){let{ex:t,ey:n,ez:r,et:o}=this.ep;const s=e.ed25519.CURVE.Fp.ORDER,i=e.ed25519.CURVE.Fp.create,f=i(i(r+n)*i(r-n)),u=i(t*n),d=i(u*u),{value:h}=j(i(f*d)),l=i(h*f),y=i(h*u),p=i(l*y*o);let b;if((0,a.isNegativeLE)(o*p,s)){let e=i(n*F),r=i(t*F);t=e,n=r,b=i(l*D)}else b=y;(0,a.isNegativeLE)(t*p,s)&&(n=i(-n));let w=i((r-n)*b);return(0,a.isNegativeLE)(w,s)&&(w=i(-w)),(0,c.numberToBytesLE)(w,32)}toHex(){return(0,c.bytesToHex)(this.toRawBytes())}toString(){return this.toHex()}equals(t){P(t);const{ex:n,ey:r}=this.ep,{ex:o,ey:s}=t.ep,i=e.ed25519.CURVE.Fp.create,a=i(n*s)===i(r*o),c=i(r*s)===i(n*o);return a||c}add(t){return P(t),new K(this.ep.add(t.ep))}subtract(t){return P(t),new K(this.ep.subtract(t.ep))}multiply(t){return new K(this.ep.multiply(t))}multiplyUnsafe(t){return new K(this.ep.multiplyUnsafe(t))}double(){return new K(this.ep.double())}negate(){return new K(this.ep.negate())}}e.RistrettoPoint=(()=>(K.BASE||(K.BASE=new K(e.ed25519.ExtendedPoint.BASE)),K.ZERO||(K.ZERO=new K(e.ed25519.ExtendedPoint.ZERO)),K))();const $=(t,e)=>{const n=e.DST,s="string"===typeof n?(0,o.utf8ToBytes)(n):n,i=(0,f.expand_message_xmd)(t,s,64,r.sha512),a=K.hashToCurve(i);return a};e.hashToRistretto255=$,e.hash_to_ristretto255=e.hashToRistretto255},b11a:function(t,e,n){"use strict";n("d9e2"),n("13d5"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1"),n("669d"),n("109c"),n("b2c1"),Object.defineProperty(e,"__esModule",{value:!0}),e.createHasher=e.isogenyMap=e.hash_to_field=e.expand_message_xof=e.expand_message_xmd=void 0;const r=n("4a19"),o=n("1a9a");function s(t){if((0,o.isBytes)(t))return t;if("string"===typeof t)return(0,o.utf8ToBytes)(t);throw new Error("DST must be Uint8Array or string")}const i=o.bytesToNumberBE;function a(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=255&t,t>>>=8;return new Uint8Array(n)}function c(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function f(t){if(!(0,o.isBytes)(t))throw new Error("Uint8Array expected")}function u(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function d(t,e,n,r){f(t),f(e),u(n),e.length>255&&(e=r((0,o.concatBytes)((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:i}=r,d=Math.ceil(n/s);if(d>255)throw new Error("Invalid xmd length");const h=(0,o.concatBytes)(e,a(e.length,1)),l=a(0,i),y=a(n,2),p=new Array(d),b=r((0,o.concatBytes)(l,t,y,a(0,1),h));p[0]=r((0,o.concatBytes)(b,a(1,1),h));for(let f=1;f<=d;f++){const t=[c(b,p[f-1]),a(f+1,1),h];p[f]=r((0,o.concatBytes)(...t))}const w=(0,o.concatBytes)(...p);return w.slice(0,n)}function h(t,e,n,r,s){if(f(t),f(e),u(n),e.length>255){const t=Math.ceil(2*r/8);e=s.create({dkLen:t}).update((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:n}).update(t).update(a(n,2)).update(e).update(a(e.length,1)).digest()}function l(t,e,n){(0,o.validateObject)(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:a,k:c,m:l,hash:y,expand:p,DST:b}=n;f(t),u(e);const w=s(b),g=a.toString(2).length,m=Math.ceil((g+c)/8),B=e*l*m;let E;if("xmd"===p)E=d(t,w,B,y);else if("xof"===p)E=h(t,w,B,c,y);else{if("_internal_pass"!==p)throw new Error('expand must be "xmd" or "xof"');E=t}const x=new Array(e);for(let o=0;o<e;o++){const t=new Array(l);for(let e=0;e<l;e++){const n=m*(e+o*l),s=E.subarray(n,n+m);t[e]=(0,r.mod)(i(s),a)}x[o]=t}return x}function y(t,e){const n=e.map(t=>Array.from(t).reverse());return(e,r)=>{const[o,s,i,a]=n.map(n=>n.reduce((n,r)=>t.add(t.mul(n,e),r)));return e=t.div(o,s),r=t.mul(r,t.div(i,a)),{x:e,y:r}}}function p(t,e,n){if("function"!==typeof e)throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=l(r,2,{...n,DST:n.DST,...o}),i=t.fromAffine(e(s[0])),a=t.fromAffine(e(s[1])),c=i.add(a).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const s=l(r,1,{...n,DST:n.encodeDST,...o}),i=t.fromAffine(e(s[0])).clearCofactor();return i.assertValidity(),i}}}e.expand_message_xmd=d,e.expand_message_xof=h,e.hash_to_field=l,e.isogenyMap=y,e.createHasher=p},b40a:function(t,e,n){"use strict";function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("Wrong positive integer: "+t)}function o(t){if("boolean"!==typeof t)throw new Error("Expected boolean, not "+t)}function s(t){return t instanceof Uint8Array||null!=t&&"object"===typeof t&&"Uint8Array"===t.constructor.name}function i(t,...e){if(!s(t))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function a(t){if("function"!==typeof t||"function"!==typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen),r(t.blockLen)}function c(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function f(t,e){i(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}Object.defineProperty(e,"__esModule",{value:!0}),e.output=e.exists=e.hash=e.bytes=e.bool=e.number=void 0,e.number=r,e.bool=o,e.bytes=i,e.hash=a,e.exists=c,e.output=f;const u={number:r,bool:o,bytes:i,hash:a,exists:c,output:f};e.default=u},b4a1:function(t,e,n){"use strict";n("d9e2"),n("14d9"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1"),n("669d"),n("109c"),n("b2c1"),Object.defineProperty(e,"__esModule",{value:!0}),e.mapToCurveSimpleSWU=e.SWUFpSqrtRatio=e.weierstrass=e.weierstrassPoints=e.DER=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=n("4a19"),o=n("1a9a"),s=n("1a9a"),i=n("ae16");function a(t){const e=(0,i.validateBasic)(t);o.validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:s}=e;if(n){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!==typeof n||"bigint"!==typeof n.beta||"function"!==typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:c,hexToBytes:f}=o;e.DER={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:n}=e.DER;if(t.length<2||2!==t[0])throw new n("Invalid signature integer tag");const r=t[1],o=t.subarray(2,r+2);if(!r||o.length!==r)throw new n("Invalid signature integer: wrong length");if(128&o[0])throw new n("Invalid signature integer: negative");if(0===o[0]&&!(128&o[1]))throw new n("Invalid signature integer: unnecessary leading zero");return{d:c(o),l:t.subarray(r+2)}},toSig(t){const{Err:n}=e.DER,r="string"===typeof t?f(t):t;if(!o.isBytes(r))throw new Error("ui8a expected");let s=r.length;if(s<2||48!=r[0])throw new n("Invalid signature tag");if(r[1]!==s-2)throw new n("Invalid signature: incorrect length");const{d:i,l:a}=e.DER._parseInt(r.subarray(2)),{d:c,l:u}=e.DER._parseInt(a);if(u.length)throw new n("Invalid signature: left bytes after parsing");return{r:i,s:c}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,n=t=>{const e=t.toString(16);return 1&e.length?"0"+e:e},r=e(n(t.s)),o=e(n(t.r)),s=r.length/2,i=o.length/2,a=n(s),c=n(i);return`30${n(i+s+4)}02${c}${o}02${a}${r}`}};const u=BigInt(0),d=BigInt(1),h=BigInt(2),l=BigInt(3),y=BigInt(4);function p(t){const e=a(t),{Fp:n}=e,c=e.toBytes||((t,e,r)=>{const s=e.toAffine();return o.concatBytes(Uint8Array.from([4]),n.toBytes(s.x),n.toBytes(s.y))}),f=e.fromBytes||(t=>{const e=t.subarray(1),r=n.fromBytes(e.subarray(0,n.BYTES)),o=n.fromBytes(e.subarray(n.BYTES,2*n.BYTES));return{x:r,y:o}});function h(t){const{a:r,b:o}=e,s=n.sqr(t),i=n.mul(s,t);return n.add(n.add(i,n.mul(t,r)),o)}if(!n.eql(n.sqr(e.Gy),h(e.Gx)))throw new Error("bad generator point: equation left != right");function y(t){return"bigint"===typeof t&&u<t&&t<e.n}function p(t){if(!y(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function b(t){const{allowedPrivateKeyLengths:n,nByteLength:i,wrapPrivateKey:a,n:c}=e;if(n&&"bigint"!==typeof t){if(o.isBytes(t)&&(t=o.bytesToHex(t)),"string"!==typeof t||!n.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*i,"0")}let f;try{f="bigint"===typeof t?t:o.bytesToNumberBE((0,s.ensureBytes)("private key",t,i))}catch(u){throw new Error(`private key must be ${i} bytes, hex or bigint, not ${typeof t}`)}return a&&(f=r.mod(f,c)),p(f),f}const w=new Map;function g(t){if(!(t instanceof m))throw new Error("ProjectivePoint expected")}class m{constructor(t,e,r){if(this.px=t,this.py=e,this.pz=r,null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required")}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof m)throw new Error("projective point not allowed");const o=t=>n.eql(t,n.ZERO);return o(e)&&o(r)?m.ZERO:new m(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=n.invertBatch(t.map(t=>t.pz));return t.map((t,n)=>t.toAffine(e[n])).map(m.fromAffine)}static fromHex(t){const e=m.fromAffine(f((0,s.ensureBytes)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return m.BASE.multiply(b(t))}_setWindowSize(t){this._WINDOW_SIZE=t,w.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:r}=this.toAffine();if(!n.isValid(t)||!n.isValid(r))throw new Error("bad point: x or y not FE");const o=n.sqr(r),s=h(t);if(!n.eql(o,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){g(t);const{px:e,py:r,pz:o}=this,{px:s,py:i,pz:a}=t,c=n.eql(n.mul(e,a),n.mul(s,o)),f=n.eql(n.mul(r,a),n.mul(i,o));return c&&f}negate(){return new m(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,o=n.mul(r,l),{px:s,py:i,pz:a}=this;let c=n.ZERO,f=n.ZERO,u=n.ZERO,d=n.mul(s,s),h=n.mul(i,i),y=n.mul(a,a),p=n.mul(s,i);return p=n.add(p,p),u=n.mul(s,a),u=n.add(u,u),c=n.mul(t,u),f=n.mul(o,y),f=n.add(c,f),c=n.sub(h,f),f=n.add(h,f),f=n.mul(c,f),c=n.mul(p,c),u=n.mul(o,u),y=n.mul(t,y),p=n.sub(d,y),p=n.mul(t,p),p=n.add(p,u),u=n.add(d,d),d=n.add(u,d),d=n.add(d,y),d=n.mul(d,p),f=n.add(f,d),y=n.mul(i,a),y=n.add(y,y),d=n.mul(y,p),c=n.sub(c,d),u=n.mul(y,h),u=n.add(u,u),u=n.add(u,u),new m(c,f,u)}add(t){g(t);const{px:r,py:o,pz:s}=this,{px:i,py:a,pz:c}=t;let f=n.ZERO,u=n.ZERO,d=n.ZERO;const h=e.a,y=n.mul(e.b,l);let p=n.mul(r,i),b=n.mul(o,a),w=n.mul(s,c),B=n.add(r,o),E=n.add(i,a);B=n.mul(B,E),E=n.add(p,b),B=n.sub(B,E),E=n.add(r,s);let x=n.add(i,c);return E=n.mul(E,x),x=n.add(p,w),E=n.sub(E,x),x=n.add(o,s),f=n.add(a,c),x=n.mul(x,f),f=n.add(b,w),x=n.sub(x,f),d=n.mul(h,E),f=n.mul(y,w),d=n.add(f,d),f=n.sub(b,d),d=n.add(b,d),u=n.mul(f,d),b=n.add(p,p),b=n.add(b,p),w=n.mul(h,w),E=n.mul(y,E),b=n.add(b,w),w=n.sub(p,w),w=n.mul(h,w),E=n.add(E,w),p=n.mul(b,E),u=n.add(u,p),p=n.mul(x,E),f=n.mul(B,f),f=n.sub(f,p),p=n.mul(B,b),d=n.mul(x,d),d=n.add(d,p),new m(f,u,d)}subtract(t){return this.add(t.negate())}is0(){return this.equals(m.ZERO)}wNAF(t){return E.wNAFCached(this,w,t,t=>{const e=n.invertBatch(t.map(t=>t.pz));return t.map((t,n)=>t.toAffine(e[n])).map(m.fromAffine)})}multiplyUnsafe(t){const r=m.ZERO;if(t===u)return r;if(p(t),t===d)return this;const{endo:o}=e;if(!o)return E.unsafeLadder(this,t);let{k1neg:s,k1:i,k2neg:a,k2:c}=o.splitScalar(t),f=r,h=r,l=this;while(i>u||c>u)i&d&&(f=f.add(l)),c&d&&(h=h.add(l)),l=l.double(),i>>=d,c>>=d;return s&&(f=f.negate()),a&&(h=h.negate()),h=new m(n.mul(h.px,o.beta),h.py,h.pz),f.add(h)}multiply(t){p(t);let r,o,s=t;const{endo:i}=e;if(i){const{k1neg:t,k1:e,k2neg:a,k2:c}=i.splitScalar(s);let{p:f,f:u}=this.wNAF(e),{p:d,f:h}=this.wNAF(c);f=E.constTimeNegate(t,f),d=E.constTimeNegate(a,d),d=new m(n.mul(d.px,i.beta),d.py,d.pz),r=f.add(d),o=u.add(h)}else{const{p:t,f:e}=this.wNAF(s);r=t,o=e}return m.normalizeZ([r,o])[0]}multiplyAndAddUnsafe(t,e,n){const r=m.BASE,o=(t,e)=>e!==u&&e!==d&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),s=o(this,e).add(o(t,n));return s.is0()?void 0:s}toAffine(t){const{px:e,py:r,pz:o}=this,s=this.is0();null==t&&(t=s?n.ONE:n.inv(o));const i=n.mul(e,t),a=n.mul(r,t),c=n.mul(o,t);if(s)return{x:n.ZERO,y:n.ZERO};if(!n.eql(c,n.ONE))throw new Error("invZ was invalid");return{x:i,y:a}}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===d)return!0;if(n)return n(m,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===d?this:n?n(m,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),c(m,this,t)}toHex(t=!0){return o.bytesToHex(this.toRawBytes(t))}}m.BASE=new m(e.Gx,e.Gy,n.ONE),m.ZERO=new m(n.ZERO,n.ONE,n.ZERO);const B=e.nBitLength,E=(0,i.wNAF)(m,e.endo?Math.ceil(B/2):B);return{CURVE:e,ProjectivePoint:m,normPrivateKeyToScalar:b,weierstrassEquation:h,isWithinCurveOrder:y}}function b(t){const e=(0,i.validateBasic)(t);return o.validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function w(t){const n=b(t),{Fp:i,n:a}=n,c=i.BYTES+1,f=2*i.BYTES+1;function h(t){return u<t&&t<i.ORDER}function l(t){return r.mod(t,a)}function y(t){return r.invert(t,a)}const{ProjectivePoint:w,normPrivateKeyToScalar:g,weierstrassEquation:m,isWithinCurveOrder:B}=p({...n,toBytes(t,e,n){const r=e.toAffine(),s=i.toBytes(r.x),a=o.concatBytes;return n?a(Uint8Array.from([e.hasEvenY()?2:3]),s):a(Uint8Array.from([4]),s,i.toBytes(r.y))},fromBytes(t){const e=t.length,n=t[0],r=t.subarray(1);if(e!==c||2!==n&&3!==n){if(e===f&&4===n){const t=i.fromBytes(r.subarray(0,i.BYTES)),e=i.fromBytes(r.subarray(i.BYTES,2*i.BYTES));return{x:t,y:e}}throw new Error(`Point of length ${e} was invalid. Expected ${c} compressed bytes or ${f} uncompressed bytes`)}{const t=o.bytesToNumberBE(r);if(!h(t))throw new Error("Point is not on curve");const e=m(t);let s=i.sqrt(e);const a=(s&d)===d,c=1===(1&n);return c!==a&&(s=i.neg(s)),{x:t,y:s}}}}),E=t=>o.bytesToHex(o.numberToBytesBE(t,n.nByteLength));function x(t){const e=a>>d;return t>e}function v(t){return x(t)?l(-t):t}const S=(t,e,n)=>o.bytesToNumberBE(t.slice(e,n));class A{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){const e=n.nByteLength;return t=(0,s.ensureBytes)("compactSignature",t,2*e),new A(S(t,0,e),S(t,e,2*e))}static fromDER(t){const{r:n,s:r}=e.DER.toSig((0,s.ensureBytes)("DER",t));return new A(n,r)}assertValidity(){if(!B(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!B(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new A(this.r,this.s,t)}recoverPublicKey(t){const{r:e,s:r,recovery:o}=this,a=_((0,s.ensureBytes)("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const c=2===o||3===o?e+n.n:e;if(c>=i.ORDER)throw new Error("recovery id 2 or 3 invalid");const f=0===(1&o)?"02":"03",u=w.fromHex(f+E(c)),d=y(c),h=l(-a*d),p=l(r*d),b=w.BASE.multiplyAndAddUnsafe(u,h,p);if(!b)throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return x(this.s)}normalizeS(){return this.hasHighS()?new A(this.r,l(-this.s),this.recovery):this}toDERRawBytes(){return o.hexToBytes(this.toDERHex())}toDERHex(){return e.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return o.hexToBytes(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const I={isValidPrivateKey(t){try{return g(t),!0}catch(e){return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const t=r.getMinHashLength(n.n);return r.mapHashToField(n.randomBytes(t),n.n)},precompute(t=8,e=w.BASE){return e._setWindowSize(t),e.multiply(BigInt(3)),e}};function O(t,e=!0){return w.fromPrivateKey(t).toRawBytes(e)}function L(t){const e=o.isBytes(t),n="string"===typeof t,r=(e||n)&&t.length;return e?r===c||r===f:n?r===2*c||r===2*f:t instanceof w}function T(t,e,n=!0){if(L(t))throw new Error("first arg must be private key");if(!L(e))throw new Error("second arg must be public key");const r=w.fromHex(e);return r.multiply(g(t)).toRawBytes(n)}const H=n.bits2int||function(t){const e=o.bytesToNumberBE(t),r=8*t.length-n.nBitLength;return r>0?e>>BigInt(r):e},_=n.bits2int_modN||function(t){return l(H(t))},R=o.bitMask(n.nBitLength);function k(t){if("bigint"!==typeof t)throw new Error("bigint expected");if(!(u<=t&&t<R))throw new Error("bigint expected < 2^"+n.nBitLength);return o.numberToBytesBE(t,n.nByteLength)}function C(t,e,r=N){if(["recovered","canonical"].some(t=>t in r))throw new Error("sign() legacy options not supported");const{hash:a,randomBytes:c}=n;let{lowS:f,prehash:h,extraEntropy:p}=r;null==f&&(f=!0),t=(0,s.ensureBytes)("msgHash",t),h&&(t=(0,s.ensureBytes)("prehashed msgHash",a(t)));const b=_(t),m=g(e),E=[k(m),k(b)];if(null!=p){const t=!0===p?c(i.BYTES):p;E.push((0,s.ensureBytes)("extraEntropy",t))}const S=o.concatBytes(...E),I=b;function O(t){const e=H(t);if(!B(e))return;const n=y(e),r=w.BASE.multiply(e).toAffine(),o=l(r.x);if(o===u)return;const s=l(n*l(I+o*m));if(s===u)return;let i=(r.x===o?0:2)|Number(r.y&d),a=s;return f&&x(s)&&(a=v(s),i^=1),new A(o,a,i)}return{seed:S,k2sig:O}}const N={lowS:n.lowS,prehash:!1},U={lowS:n.lowS,prehash:!1};function P(t,e,r=N){const{seed:s,k2sig:i}=C(t,e,r),a=n,c=o.createHmacDrbg(a.hash.outputLen,a.nByteLength,a.hmac);return c(s,i)}function F(t,r,i,a=U){var c;const f=t;if(r=(0,s.ensureBytes)("msgHash",r),i=(0,s.ensureBytes)("publicKey",i),"strict"in a)throw new Error("options.strict was renamed to lowS");const{lowS:u,prehash:d}=a;let h,p=void 0;try{if("string"===typeof f||o.isBytes(f))try{p=A.fromDER(f)}catch(I){if(!(I instanceof e.DER.Err))throw I;p=A.fromCompact(f)}else{if("object"!==typeof f||"bigint"!==typeof f.r||"bigint"!==typeof f.s)throw new Error("PARSE");{const{r:t,s:e}=f;p=new A(t,e)}}h=w.fromHex(i)}catch(O){if("PARSE"===O.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(u&&p.hasHighS())return!1;d&&(r=n.hash(r));const{r:b,s:g}=p,m=_(r),B=y(g),E=l(m*B),x=l(b*B),v=null===(c=w.BASE.multiplyAndAddUnsafe(h,E,x))||void 0===c?void 0:c.toAffine();if(!v)return!1;const S=l(v.x);return S===b}return w.BASE._setWindowSize(8),{CURVE:n,getPublicKey:O,getSharedSecret:T,sign:P,verify:F,ProjectivePoint:w,Signature:A,utils:I}}function g(t,e){const n=t.ORDER;let r=u;for(let l=n-d;l%h===u;l/=h)r+=d;const o=r,s=h<<o-d-d,i=s*h,a=(n-d)/i,c=(a-d)/h,f=i-d,p=s,b=t.pow(e,a),w=t.pow(e,(a+d)/h);let g=(e,n)=>{let r=b,s=t.pow(n,f),i=t.sqr(s);i=t.mul(i,n);let a=t.mul(e,i);a=t.pow(a,c),a=t.mul(a,s),s=t.mul(a,n),i=t.mul(a,e);let u=t.mul(i,s);a=t.pow(u,p);let l=t.eql(a,t.ONE);s=t.mul(i,w),a=t.mul(u,r),i=t.cmov(s,i,l),u=t.cmov(a,u,l);for(let c=o;c>d;c--){let e=c-h;e=h<<e-d;let n=t.pow(u,e);const o=t.eql(n,t.ONE);s=t.mul(i,r),r=t.mul(r,r),n=t.mul(u,r),i=t.cmov(s,i,o),u=t.cmov(n,u,o)}return{isValid:l,value:i}};if(t.ORDER%y===l){const n=(t.ORDER-l)/y,r=t.sqrt(t.neg(e));g=(e,o)=>{let s=t.sqr(o);const i=t.mul(e,o);s=t.mul(s,i);let a=t.pow(s,n);a=t.mul(a,i);const c=t.mul(a,r),f=t.mul(t.sqr(a),o),u=t.eql(f,e);let d=t.cmov(c,a,u);return{isValid:u,value:d}}}return g}function m(t,e){if(r.validateField(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const n=g(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,i,a,c,f,u,d;o=t.sqr(r),o=t.mul(o,e.Z),s=t.sqr(o),s=t.add(s,o),i=t.add(s,t.ONE),i=t.mul(i,e.B),a=t.cmov(e.Z,t.neg(s),!t.eql(s,t.ZERO)),a=t.mul(a,e.A),s=t.sqr(i),f=t.sqr(a),c=t.mul(f,e.A),s=t.add(s,c),s=t.mul(s,i),f=t.mul(f,a),c=t.mul(f,e.B),s=t.add(s,c),u=t.mul(o,i);const{isValid:h,value:l}=n(s,f);d=t.mul(o,r),d=t.mul(d,l),u=t.cmov(u,i,h),d=t.cmov(d,l,h);const y=t.isOdd(r)===t.isOdd(d);return d=t.cmov(t.neg(d),d,y),u=t.div(u,a),{x:u,y:d}}}e.weierstrassPoints=p,e.weierstrass=w,e.SWUFpSqrtRatio=g,e.mapToCurveSimpleSWU=m},d129:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sha224=e.sha256=void 0;const r=n("993b"),o=n("531d"),s=(t,e,n)=>t&e^~t&n,i=(t,e,n)=>t&e^t&n^e&n,a=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),c=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),f=new Uint32Array(64);class u extends r.SHA2{constructor(){super(64,32,8,!1),this.A=0|c[0],this.B=0|c[1],this.C=0|c[2],this.D=0|c[3],this.E=0|c[4],this.F=0|c[5],this.G=0|c[6],this.H=0|c[7]}get(){const{A:t,B:e,C:n,D:r,E:o,F:s,G:i,H:a}=this;return[t,e,n,r,o,s,i,a]}set(t,e,n,r,o,s,i,a){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|s,this.G=0|i,this.H=0|a}process(t,e){for(let o=0;o<16;o++,e+=4)f[o]=t.getUint32(e,!1);for(let s=16;s<64;s++){const t=f[s-15],e=f[s-2],n=(0,o.rotr)(t,7)^(0,o.rotr)(t,18)^t>>>3,r=(0,o.rotr)(e,17)^(0,o.rotr)(e,19)^e>>>10;f[s]=r+f[s-7]+n+f[s-16]|0}let{A:n,B:r,C:c,D:u,E:d,F:h,G:l,H:y}=this;for(let p=0;p<64;p++){const t=(0,o.rotr)(d,6)^(0,o.rotr)(d,11)^(0,o.rotr)(d,25),e=y+t+s(d,h,l)+a[p]+f[p]|0,b=(0,o.rotr)(n,2)^(0,o.rotr)(n,13)^(0,o.rotr)(n,22),w=b+i(n,r,c)|0;y=l,l=h,h=d,d=u+e|0,u=c,c=r,r=n,n=e+w|0}n=n+this.A|0,r=r+this.B|0,c=c+this.C|0,u=u+this.D|0,d=d+this.E|0,h=h+this.F|0,l=l+this.G|0,y=y+this.H|0,this.set(n,r,c,u,d,h,l,y)}roundClean(){f.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class d extends u{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}e.sha256=(0,o.wrapConstructor)(()=>new u),e.sha224=(0,o.wrapConstructor)(()=>new d)},d16c:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto="object"===typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},dd3b:function(t,e,n){"use strict";n("d9e2"),Object.defineProperty(e,"__esModule",{value:!0}),e.montgomery=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=n("4a19"),o=n("1a9a"),s=BigInt(0),i=BigInt(1);function a(t){return(0,o.validateObject)(t,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...t})}function c(t){const e=a(t),{P:n}=e,c=t=>(0,r.mod)(t,n),f=e.montgomeryBits,u=Math.ceil(f/8),d=e.nByteLength,h=e.adjustScalarBytes||(t=>t),l=e.powPminus2||(t=>(0,r.pow)(t,n-BigInt(2),n));function y(t,e,n){const r=c(t*(e-n));return e=c(e-r),n=c(n+r),[e,n]}function p(t){if("bigint"===typeof t&&s<=t&&t<n)return t;throw new Error("Expected valid scalar 0 < scalar < CURVE.P")}const b=(e.a-BigInt(2))/BigInt(4);function w(t,e){const n=p(t),r=p(e),o=n;let a,u=i,d=s,h=n,w=i,g=s;for(let l=BigInt(f-1);l>=s;l--){const t=r>>l&i;g^=t,a=y(g,u,h),u=a[0],h=a[1],a=y(g,d,w),d=a[0],w=a[1],g=t;const e=u+d,n=c(e*e),s=u-d,f=c(s*s),p=n-f,m=h+w,B=h-w,E=c(B*e),x=c(m*s),v=E+x,S=E-x;h=c(v*v),w=c(o*c(S*S)),u=c(n*f),d=c(p*(n+c(b*p)))}a=y(g,u,h),u=a[0],h=a[1],a=y(g,d,w),d=a[0],w=a[1];const m=l(d);return c(u*m)}function g(t){return(0,o.numberToBytesLE)(c(t),u)}function m(t){const e=(0,o.ensureBytes)("u coordinate",t,u);return 32===d&&(e[31]&=127),(0,o.bytesToNumberLE)(e)}function B(t){const e=(0,o.ensureBytes)("scalar",t),n=e.length;if(n!==u&&n!==d)throw new Error(`Expected ${u} or ${d} bytes, got ${n}`);return(0,o.bytesToNumberLE)(h(e))}function E(t,e){const n=m(e),r=B(t),o=w(n,r);if(o===s)throw new Error("Invalid private or public key received");return g(o)}const x=g(e.Gu);function v(t){return E(t,x)}return{scalarMult:E,scalarMultBase:v,getSharedSecret:(t,e)=>E(t,e),getPublicKey:t=>v(t),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:x}}e.montgomery=c},e632:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=e.HMAC=void 0;const r=n("b40a"),o=n("531d");class s extends o.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,r.hash)(t);const n=(0,o.toBytes)(e);if(this.iHash=t.create(),"function"!==typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?t.create().update(n).digest():n);for(let r=0;r<i.length;r++)i[r]^=54;this.iHash.update(i),this.oHash=t.create();for(let r=0;r<i.length;r++)i[r]^=106;this.oHash.update(i),i.fill(0)}update(t){return(0,r.exists)(this),this.iHash.update(t),this}digestInto(t){(0,r.exists)(this),(0,r.bytes)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:s,outputLen:i}=this;return t=t,t.finished=r,t.destroyed=o,t.blockLen=s,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}e.HMAC=s;const i=(t,e,n)=>new s(t,e).update(n).digest();e.hmac=i,e.hmac.create=(t,e)=>new s(t,e)},fb4a:function(t,e,n){"use strict";n("d9e2"),n("907a"),n("986a"),n("1d02"),n("3c5d"),n("6ce5"),n("2834"),n("4ea1"),n("669d"),n("109c"),n("b2c1"),Object.defineProperty(e,"__esModule",{value:!0}),e.encodeToCurve=e.hashToCurve=e.schnorr=e.secp256k1=void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=n("d129"),o=n("531d"),s=n("4a19"),i=n("b4a1"),a=n("1a9a"),c=n("b11a"),f=n("84d6"),u=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),d=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h=BigInt(1),l=BigInt(2),y=(t,e)=>(t+e/l)/e;function p(t){const e=u,n=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),a=BigInt(23),c=BigInt(44),f=BigInt(88),d=t*t*t%e,h=d*d*t%e,y=(0,s.pow2)(h,n,e)*h%e,p=(0,s.pow2)(y,n,e)*h%e,w=(0,s.pow2)(p,l,e)*d%e,g=(0,s.pow2)(w,o,e)*w%e,m=(0,s.pow2)(g,i,e)*g%e,B=(0,s.pow2)(m,c,e)*m%e,E=(0,s.pow2)(B,f,e)*B%e,x=(0,s.pow2)(E,c,e)*m%e,v=(0,s.pow2)(x,n,e)*h%e,S=(0,s.pow2)(v,a,e)*g%e,A=(0,s.pow2)(S,r,e)*d%e,I=(0,s.pow2)(A,l,e);if(!b.eql(b.sqr(I),t))throw new Error("Cannot find square root");return I}const b=(0,s.Field)(u,void 0,void 0,{sqrt:p});e.secp256k1=(0,f.createCurve)({a:BigInt(0),b:BigInt(7),Fp:b,n:d,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=d,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-h*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,a=BigInt("0x100000000000000000000000000000000"),c=y(i*t,e),f=y(-r*t,e);let u=(0,s.mod)(t-c*n-f*o,e),l=(0,s.mod)(-c*r-f*i,e);const p=u>a,b=l>a;if(p&&(u=e-u),b&&(l=e-l),u>a||l>a)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:p,k1:u,k2neg:b,k2:l}}}},r.sha256);const w=BigInt(0),g=t=>"bigint"===typeof t&&w<t&&t<u,m=t=>"bigint"===typeof t&&w<t&&t<d,B={};function E(t,...e){let n=B[t];if(void 0===n){const e=(0,r.sha256)(Uint8Array.from(t,t=>t.charCodeAt(0)));n=(0,a.concatBytes)(e,e),B[t]=n}return(0,r.sha256)((0,a.concatBytes)(n,...e))}const x=t=>t.toRawBytes(!0).slice(1),v=t=>(0,a.numberToBytesBE)(t,32),S=t=>(0,s.mod)(t,u),A=t=>(0,s.mod)(t,d),I=e.secp256k1.ProjectivePoint,O=(t,e,n)=>I.BASE.multiplyAndAddUnsafe(t,e,n);function L(t){let n=e.secp256k1.utils.normPrivateKeyToScalar(t),r=I.fromPrivateKey(n);const o=r.hasEvenY()?n:A(-n);return{scalar:o,bytes:x(r)}}function T(t){if(!g(t))throw new Error("bad x: need 0 < x < p");const e=S(t*t),n=S(e*t+BigInt(7));let r=p(n);r%l!==w&&(r=S(-r));const o=new I(t,r,h);return o.assertValidity(),o}function H(...t){return A((0,a.bytesToNumberBE)(E("BIP0340/challenge",...t)))}function _(t){return L(t).bytes}function R(t,e,n=(0,o.randomBytes)(32)){const r=(0,a.ensureBytes)("message",t),{bytes:s,scalar:i}=L(e),c=(0,a.ensureBytes)("auxRand",n,32),f=v(i^(0,a.bytesToNumberBE)(E("BIP0340/aux",c))),u=E("BIP0340/nonce",f,s,r),d=A((0,a.bytesToNumberBE)(u));if(d===w)throw new Error("sign failed: k is zero");const{bytes:h,scalar:l}=L(d),y=H(h,s,r),p=new Uint8Array(64);if(p.set(h,0),p.set(v(A(l+y*i)),32),!k(p,r,s))throw new Error("sign: Invalid signature produced");return p}function k(t,e,n){const r=(0,a.ensureBytes)("signature",t,64),o=(0,a.ensureBytes)("message",e),s=(0,a.ensureBytes)("publicKey",n,32);try{const t=T((0,a.bytesToNumberBE)(s)),e=(0,a.bytesToNumberBE)(r.subarray(0,32));if(!g(e))return!1;const n=(0,a.bytesToNumberBE)(r.subarray(32,64));if(!m(n))return!1;const i=H(v(e),x(t),o),c=O(t,n,A(-i));return!(!c||!c.hasEvenY()||c.toAffine().x!==e)}catch(i){return!1}}e.schnorr=(()=>({getPublicKey:_,sign:R,verify:k,utils:{randomPrivateKey:e.secp256k1.utils.randomPrivateKey,lift_x:T,pointToBytes:x,numberToBytesBE:a.numberToBytesBE,bytesToNumberBE:a.bytesToNumberBE,taggedHash:E,mod:s.mod}}))();const C=(()=>(0,c.isogenyMap)(b,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(t=>BigInt(t)))))(),N=(()=>(0,i.mapToCurveSimpleSWU)(b,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:b.create(BigInt("-11"))}))(),U=(()=>(0,c.createHasher)(e.secp256k1.ProjectivePoint,t=>{const{x:e,y:n}=N(b.create(t[0]));return C(e,n)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:b.ORDER,m:1,k:128,expand:"xmd",hash:r.sha256}))();e.hashToCurve=(()=>U.hashToCurve)(),e.encodeToCurve=(()=>U.encodeToCurve)()}}]);